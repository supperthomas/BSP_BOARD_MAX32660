<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>MAX32660 SDK Documentation: API Overview and Usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 44px;">
  <td id="projectlogo" style="vertical-align:middle"><img alt="Logo" style="width:144px;height:63px;" src="MI_Logo_Small_Pos_RGB_150dpi.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAX32660 SDK Documentation
   &#160;<span id="projectnumber">2.7.5.0</span>
   </div>
   <div id="projectbrief">Software Development Kit Overview and API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_API_Overview_and_Usage.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">API Overview and Usage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#introPage">Introduction</a></li>
<li class="level1"><a href="#cmsisPage">CMSIS</a><ul><li class="level2"><a href="#regHeadersPage">Register-level Header Files</a></li>
<li class="level2"><a href="#startupCodePage">Startup Code</a></li>
<li class="level2"><a href="#periphDriverPage">Peripheral Drivers</a></li>
<li class="level2"><a href="#sysLayerPage">System Layer</a></li>
<li class="level2"><a href="#bspPage">Board Support Package</a></li>
</ul>
</li>
<li class="level1"><a href="#asyncAPIPage">Synchronous vs. Asynchronous APIs</a></li>
<li class="level1"><a href="#lpPage">Low-power API Considerations</a></li>
<li class="level1"><a href="#debugAssertPage">Debug Assertions</a></li>
<li class="level1"><a href="#makefilePage">Makefile Structure and Building Projects</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="introPage"></a>
Introduction</h1>
<p>This document describes the MAX32660 Firmware SDK and gives a broad overview for new developers. This modular, flexible SDK increases the reusability of code between devices and gives the developer a robust framework for creating custom applications, hardware platforms, and libraries.</p>
<p>The MAX32660 Firmware SDK consists of example applications and peripheral drivers which use a common API. These components are contained in a directory tree, and the structure of the directory hierarchy is shown in <a class="el" href="md_API_Overview_and_Usage.html#figure1_overview">Figure 1</a>. The directory <em>Applications</em> holds the example applications and may contain any custom applications that the user creates. The <em>Libraries</em> directory contains the core CMSIS libraries, the chip-specific peripheral drivers, and the board support files.</p>
<p>Additional libraries may be included with the SDK, and the build environment allows for user-created libraries to be included into an application.</p>
<p><a class="anchor" id="figure1_overview"></a></p><div class="image">
<img src="FirmwareSDKDirStruct.png" alt="FirmwareSDKDirStruct.png" width="50%" height="50%"/>
<div class="caption">
MAX32665 Firmware SDK Directory Structure</div></div>
<h1><a class="anchor" id="cmsisPage"></a>
CMSIS</h1>
<p>CMSIS is the Cortex Microcontroller Software Interface Standard produced by ARM and is used in this SDK. It is a standardized hardware abstraction layer that separates the complexity of the hardware from the software developer.</p>
<p><a class="el" href="md_API_Overview_and_Usage.html#figure2_overview">Figure 2</a> shows the hierarchy of the SDK libraries and APIs. The application layer primarily interacts with the peripheral drivers and the board drivers, but can also directly use the pointers and definitions in the CMSIS layer to manipulate the hardware.</p>
<p><a class="anchor" id="figure2_overview"></a></p><div class="image">
<img src="FirmwareSDKHierarchy.png" alt="FirmwareSDKHierarchy.png" width="50%" height="50%"/>
<div class="caption">
MAX32665 Firmware SDK Hierarchy</div></div>
<h2><a class="anchor" id="regHeadersPage"></a>
Register-level Header Files</h2>
<p>The MAX32660 microcontrollers contain multiple peripherals which can be configured through memory-mapped registers. The directory <em>Libraries/CMSIS/Device/Maxim/&lt;Device&gt;/Include</em> contains one header file per peripheral which defines a structure containing the registers for the peripheral. The header file also contains a set of C pre-processor definitions for each register to read and manipulate the bits within the associated register.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MXC_F_ADC_CTRL_CPU_ADC_START                  1               </span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    __IO uint32_t ctrl;          <span class="comment">/*  0x0000 UART Control Register */</span>                     </div><div class="line">    __IO uint32_t baud;          <span class="comment">/*  0x0004 UART Baud Control Register */</span></div><div class="line">    __IO uint32_t tx_fifo_ctrl;  <span class="comment">/*  0x0008 UART TX FIFO Control Register */</span></div><div class="line"> <span class="comment">/* .. registers omitted .. */</span></div><div class="line">} mxc_adc_regs_t;</div><div class="line"></div><div class="line"><span class="preprocessor">#define MXC_R_UART_OFFS_CTRL                      ((uint32_t)0x00000000UL)</span></div><div class="line"><span class="preprocessor">#define MXC_R_UART_OFFS_BAUD                      ((uint32_t)0x00000004UL)</span></div><div class="line"><span class="preprocessor">#define MXC_R_UART_OFFS_TX_FIFO_CTRL              ((uint32_t)0x00000008UL)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define MXC_F_UART_CTRL_UART_EN_POS               0</span></div><div class="line"><span class="preprocessor">#define MXC_F_UART_CTRL_UART_EN                   ((uint32_t)(0x00000001UL &lt;&lt; \\    </span></div><div class="line">                                                    MXC_F_UART_CTRL_UART_EN_POS))</div><div class="line"><span class="preprocessor">#define MXC_F_UART_CTRL_RX_FIFO_EN_POS            1</span></div><div class="line"><span class="preprocessor">#define MXC_F_UART_CTRL_RX_FIFO_EN                ((uint32_t)(0x00000001UL &lt;&lt; \\</span></div><div class="line"><span class="preprocessor">                                                    MXC_F_UART_CTRL_RX_FIFO_EN_POS))</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define MXC_V_UART_CTRL_DATA_SIZE_5_BITS   ((uint32_t)(0x00000000UL))</span></div><div class="line"><span class="preprocessor">#define MXC_V_UART_CTRL_DATA_SIZE_6_BITS   ((uint32_t)(0x00000001UL))</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define MXC_S_UART_CTRL_DATA_SIZE_5_BITS \\</span></div><div class="line"><span class="preprocessor">   ((uint32_t)(MXC_V_UART_CTRL_DATA_SIZE_5_BITS &lt;&lt; MXC_F_UART_CTRL_DATA_SIZE_POS))</span></div><div class="line"><span class="preprocessor">#define MXC_S_UART_CTRL_DATA_SIZE_6_BITS \\</span></div><div class="line"><span class="preprocessor">   ((uint32_t)(MXC_V_UART_CTRL_DATA_SIZE_6_BITS &lt;&lt; MXC_F_UART_CTRL_DATA_SIZE_POS))</span></div></div><!-- fragment --><p>The example above shows a peripheral with several control registers. The “_R_” denotes a register definition, “_F_” denotes a field definition, “_V_” denotes a value definition, and “_S_” denotes a setting definition. Register definitions give the address offset in bytes from the start of the register struct. Field definitions with the “_POS” suffix denote the bit position of the field, or a mask for all of the bits in the field without the suffix. Settings are values that have been shifted into the proper bit position within a register. Also included with the register files is a device specific file that contains all of the unique addresses of the peripherals, definitions for memory sizes and locations, as well as interrupt vector numbers.</p>
<h2><a class="anchor" id="startupCodePage"></a>
Startup Code</h2>
<p>The directory <em>Libraries/CMSIS/Device/Maxim/&lt;Device&gt;/Source</em> contains the chip-specific startup file <b>system_MAX32665.c</b>. The routines in this file contain the compiler-agnostic CMSIS startup routines <code>PreInit</code> and <code>SystemInit</code>. Additionally, the Maxim CMSIS environment defines <code>Board_Init</code> in this file. The code <code>PreInit</code> and <code>SystemInit</code> handles device-specific configuration, and <code>Board_Init</code> is used to set up the board-specific configuration.</p>
<p>All three functions are defined as <code>weak</code> symbols and can be overridden by the application by simply declaring a function of the same name. This will not be necessary for most applications, but may be needed for unusual use cases. If these functions are overridden, care should be taken to copy all unmodified code from the weak functions or erroneous system behavior may result.</p>
<p>Each compiler has a unique directory for the startup code, which can be found in the <em>Libraries/CMSIS/Device/Maxim/&lt;Device&gt;/Source/&lt;Compiler&gt;</em> directory. The file <em>startup_MAX32665.s</em> contains the ARM NVIC interrupt vector table and the <em>Reset_Handler</em> function. <em>Reset_Handler</em> is the first function run by the CPU when reset is released. It performs initialization of static memory allocations and other C run-time setup, eventually transferring control to <code>main</code>.</p>
<h2><a class="anchor" id="periphDriverPage"></a>
Peripheral Drivers</h2>
<p>Each peripheral of the microcontroller comes with a driver that provides an interface between the application and the hardware.</p>
<p>The drivers have a header file with definitions and function declarations. Descriptions for each API function are given in the header file and can also be found in this documentation. Most of the peripherals have associated examples illustrating a typical use case. The peripheral drivers are located in the directory <em>Libraries/MAX32665PeriphDriver</em>, with the header files located in the subdirectory <em>Include</em>.</p>
<p>Most use cases can be accomplished with the provided drivers, but specific modifications can be made using CMSIS device pointers and definitions from the register files.</p>
<h2><a class="anchor" id="sysLayerPage"></a>
System Layer</h2>
<p>A driver, <code>mxc_sys.c</code>, is provided which controls the system level initialization to support many peripherals which require chip-specific configuration. This includes any pin or clock setup required to operate properly. While these functions are available to the application, most of the peripheral drivers will call these functions when necessary.</p>
<h2><a class="anchor" id="bspPage"></a>
Board Support Package</h2>
<p>The directory <em>Libraries/Boards</em> contains board-specific configuration files. All evaluation kits are supported by the configurations contained in the SDK. Each board configuration is located in a subdirectory of <em>Libraries/Boards</em> and common code is located in the two subdirectories <em>Include</em> and <em>Source</em>.</p>
<p>Custom boards created by developers should be added to this directory and modeled after the existing boards.</p>
<h1><a class="anchor" id="asyncAPIPage"></a>
Synchronous vs. Asynchronous APIs</h1>
<p>Many of the peripheral APIs included in the SDK are provided in both a synchronous and asynchronous form. The synchronous, or "blocking", calls will not return until the data has been written to or read from the underlying hardware. Note that writing to the hardware does not necessarily mean that the hardware has completed operating on the data.</p>
<p>The asynchronous calls will return immediately with a return status that indicates whether or not the request was queued successfully. If the request could not be processed for some reason, and appropriate error code will be returned. Otherwise, the callback registered by the asynchronous call will execute upon completion of the request. This callback will execute within the interrupt context of the driver.</p>
<p>When the API provides an asynchronous interface, the suffix <code>_Async</code> will be appended to the function name. </p><div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">int</span> SPIM_Trans(mxc_spim_regs_t *spim, spim_req_t *req);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> SPIM_TransAsync(mxc_spim_regs_t *spim, spim_req_t *req);</div></div><!-- fragment --><p><b>You must not interleave synchronous and asynchronous calls on any one peripheral. Doing so may cause unexpected or incorrect behavior.</b> However, when using two different instances of a peripheral (e.g. SPI0 and SPI1), one instance may use the synchronous form while the other instance uses the asynchronous form.</p>
<p>Asynchronous callbacks are implemented with interrupts, and these interrupts need to be connected to the driver’s interrupt handler. This connection is demonstrated in the following code, which overrides the weak ISR function for SPI Master #0.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> SPIM0_IRQHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    SPIM_Handler(MXC_SPIM0);</div><div class="line">}</div></div><!-- fragment --><p>Once an asynchronous request has been registered, it may be cancelled before completion with the API calls ending in <code>_AbortAsync</code>. The callback will be activated with the error code of <a class="el" href="group__MXC__Error__Codes.html">Error Codes</a> E_ABORT. Partial data may be available from an aborted request, and the application should check for this case.</p>
<h1><a class="anchor" id="lpPage"></a>
Low-power API Considerations</h1>
<p>The MAX32665 family of devices incorporates several low-power modes, which are managed by the Low-Power (prefixed by <code>LP_</code>) driver. These low-power modes are fully explained in the product's User’s Guide.</p>
<p>The low-power mode support for the MAX32660 SDK includes provisions for each driver to signal its readiness to enter a low-power mode. This information is important when asynchronous requests are pending, so that data-on-the-wire is not lost or corrupted by the microcontroller going into a low-power mode which deprives the peripheral of power or a clock signal.</p>
<p>Each API which is sensitive to low-power entry includes an API call ending in <code>_PrepForSleep</code>. For example, the UART API call is <a class="el" href="group__uart.html#gafb029baf81f422a2cca8b2f689732a27" title="Prepare the UART for entry into a Low-Power mode (DEEPSLEEP/BACKUP). ">UART_PrepForSleep()</a>. Before entry into LP1 or LP0, any application using a UART should call this function with the appropriate UART peripheral instance pointer (e.g. <code>MXC_UART1</code>). If the return code is not <a class="el" href="group__MXC__Error__Codes.html#gaa1f0dfda864fa9d2630645f233e1fdb4" title="No Error. ">E_NO_ERROR</a>, then the calling application should delay entry into LP1 or LP0 until this function returns <a class="el" href="group__MXC__Error__Codes.html#gaa1f0dfda864fa9d2630645f233e1fdb4" title="No Error. ">E_NO_ERROR</a>.</p>
<p>One common use of this API is to ensure that the console text output has been completely sent to a remote terminal. </p><div class="fragment"><div class="line"><span class="comment">//configure wake-up on GPIO</span></div><div class="line">LP_ConfigGPIOWakeUpDetect(&amp;gpioLP1, 0, LP_WEAK_PULL_UP);</div><div class="line"></div><div class="line">printf(<span class="stringliteral">&quot;Enter LP1. Press SW2 to wake-up.\n&quot;</span>);</div><div class="line"><span class="keywordflow">while</span> (Console_PrepForSleep()!= <a class="code" href="group__MXC__Error__Codes.html#gaa1f0dfda864fa9d2630645f233e1fdb4">E_NO_ERROR</a>);</div><div class="line"></div><div class="line">LP_EnterLP1();</div></div><!-- fragment --><p>The while loop blocks until Console_PrepForSleep() reports that the UART is idle (i.e. the FIFO is empty and the stop bit has been shifted out the UART's TX pin).</p>
<p>The same call can be used to check that peripherals are not currently receiving data, as this may not be apparent to the main application until an interrupt or callback occurs.</p>
<h1><a class="anchor" id="debugAssertPage"></a>
Debug Assertions</h1>
<p>The MAX32660 SDK provides macros which can generate run-time assertions during application development. These assertions will check failure cases which should not occur after application development and debugging has concluded, and will halt program execution in a manner configurable by the developer.</p>
<p>Since these assertions may reduce system performance, they can be disabled after the development and debugging phase. The assertions themselves will remain in the source code files, but they will not be checked and have no time penalty associated with them when disabled.</p>
<p>As an example, the following SDK library code utilizes assertions to trap error conditions during development. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="group__gpio.html#gaf14fa17488bdb0e1c96c43153296ae13">GPIO_Config</a>(<span class="keyword">const</span> <a class="code" href="structgpio__cfg__t.html">gpio_cfg_t</a> *cfg)</div><div class="line">{</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pin;</div><div class="line">    <span class="keywordtype">int</span> err = <a class="code" href="group__MXC__Error__Codes.html#gaa1f0dfda864fa9d2630645f233e1fdb4">E_NO_ERROR</a>;</div><div class="line"></div><div class="line">    MXC_ASSERT(cfg);</div><div class="line">    MXC_ASSERT(cfg-&gt;<a class="code" href="structgpio__cfg__t.html#a5848cf94b21d669897dccff003bd39a5">port</a> &lt; MXC_GPIO_NUM_PORTS);</div><div class="line"></div><div class="line"><span class="comment">/* .. more code follows .. */</span></div></div><!-- fragment --><p>These checks could be very time consuming when the application is running in production, so a C pre-processor definition is used to enable them only during debugging. This can be found in the Makefile. </p><div class="fragment"><div class="line"><span class="preprocessor"># Enable assertion checking for development</span></div><div class="line"><span class="preprocessor">PROJ_CFLAGS+=-DMXC_ASSERT_ENABLE</span></div></div><!-- fragment --><p>Once the application is fully debugged, the <code>–DMXC_ASSERT_ENABLE</code> definition can be removed. This removes all the logic within the MXC_ASSERT() statement from being generated at compile time.</p>
<h1><a class="anchor" id="makefilePage"></a>
Makefile Structure and Building Projects</h1>
<p>Makefiles are used to build the libraries and example applications in the MAX32660 SDK. The SDK build environment relies on the GNU Make program.</p>
<p>The build process starts at the project Makefile, typically located in the root directory of the project. In this Makefile, many important make variables are set. The following table describes the names and the purpose of each.</p>
<table class="doxtable">
<tr>
<th align="left">Variable </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><code>PROJECT</code> </td><td align="left">Defines the name of the application, which is also used as the output filename. </td></tr>
<tr>
<td align="left"><code>TARGET</code> </td><td align="left">Sets the target processor (e.g. MAX32665, MAX32630). </td></tr>
<tr>
<td align="left"><code>TARGET_REV</code> </td><td align="left">May be used to configure the drivers for a prior version of silicon. </td></tr>
<tr>
<td align="left"><code>COMPILER</code> </td><td align="left">Selects the compiler initialization and linker map for this project. </td></tr>
<tr>
<td align="left"><code>BOARD</code> </td><td align="left">Specifies the target board (system) for additional support drivers. </td></tr>
<tr>
<td align="left"><code>SRCS</code> </td><td align="left">Holds a list of source files for this application. </td></tr>
<tr>
<td align="left"><code>PROJ_CFLAGS</code> </td><td align="left">Adds extra C pre-processor definitions to the build. </td></tr>
<tr>
<td align="left"><code>MXC_OPTIMIZE_CFLAGS</code></td><td align="left">If defined, overrides default optimization level. (e.g. <code>-O0</code>, <code>-O2</code>) </td></tr>
</table>
<p>Other, less used options are below these core set of variables. They should not need to be modified for most applications.</p>
<p>Libraries used by the application will appear next in the Makefile. Each library resides in the <em>Libraries</em> directory, or a user-specified path, and is compiled into object files which reside in the <em>build</em> directory. These object files are then linked into static libraries, which will ultimately be linked with application code.</p>
<p>Building a project is straightforward; change directories into the example application and type <code>make</code>.</p>
<div class="fragment"><div class="line">$ cd Firmware/MAX32665/Applications/EvKitExamples/SysTick</div><div class="line">$ make</div><div class="line">make -C ../../../Libraries/MAX32665PeriphDriver lib BUILD_DIR=/c/Maxim/Firmware/MAX32665/Applications/EvKitExamples/SysTick/build/PeriphDriver</div><div class="line">make[1]: Entering directory &#39;/c/Maxim/Firmware/MAX32665/Libraries/MAX32665PeriphDriver&#39;</div><div class="line">  CC    Source/clkman.c</div><div class="line">  CC    Source/crc.c</div><div class="line">  CC    Source/flc.c</div><div class="line">  CC    Source/gpio.c</div><div class="line">&lt; ... &gt;</div><div class="line">  AS    /c/Maxim/Firmware/MAX32665/Libraries/CMSIS/Device/Maxim/MAX32665/Source/GCC/startup_MAX32665.S</div><div class="line">  CC    /c/Maxim/Firmware/MAX32665/Libraries/CMSIS/Device/Maxim/MAX32665/Source/heap.c</div><div class="line">  CC    /c/Maxim/Firmware/MAX32665/Libraries/CMSIS/Device/Maxim/MAX32665/Source/system_MAX32665.c</div><div class="line">  LD    /c/Maxim/Firmware/MAX32665/Applications/EvKitExamples/SysTick/build/MAX32665.elf</div><div class="line">$ ls –l build/MAX32665.elf</div><div class="line">-rw-rw-rw-  1 joe.user  allusers  551278 Aug  4 16:57 build/MAX32665.elf*</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is not advisable to store your locally-developed application or modified examples in the evaluation kit installation directory, typically <em>C:\Maxim</em> on Windows, as updated versions of the ARM Cortex Toolchain may overwrite or remove these files and directories. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <a href="http://www.maximintegrated.com/index.html">
    <img class="footer" align="middle" src="MI_Logo_Small_Footer_RGB_150dpi.png" alt="Maxim Integrated"/></a> 2.7.5.0 </li>
  </ul>
</div>
</body>
</html>
